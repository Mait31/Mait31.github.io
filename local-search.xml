<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Node.js学习笔记03</title>
    <link href="/2022/03/25/Node.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003/"/>
    <url>/2022/03/25/Node.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003/</url>
    
    <content type="html"><![CDATA[<p>同步：同步就是你要做的事你列了一个清单，按照清单上的顺序 一个一个执行</p><p>异步：就是可以同时干好几件事</p><p>阻塞：就是按照清单上的顺序一件一件的往下走，当一件事没有做完，下面的事都干不了</p><p>非阻塞：就是这件事没有干完，后面的事不会等你这件事干完了再干，而是直接开始干下一件事，等你这件事干完了，后面的事也干完了，这样就大大提高了效率</p><p>A “callback” is any function that is called by another function which takes the first function as a parameter. （在一个函数中调用另外一个函数就是callback）</p><p><strong>net.createServer([options][,connectionListener])</strong><br>参数：<br>option: object<br>connectionListener: [function]，自动设置为connection事件的监听器。<br>返回值：创建新的 TCP服务器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> net = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;net&#x27;</span>);<br><span class="hljs-keyword">const</span> server = net.createServer(<span class="hljs-function">(<span class="hljs-params">c</span>) =&gt;</span> &#123;<br> <span class="hljs-comment">// &#x27;connection&#x27; 监听器。</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;client connected&#x27;</span>);<br>  c.on(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;client disconnected&#x27;</span>);<br>  &#125;);<br>  c.write(<span class="hljs-string">&#x27;hello\r\n&#x27;</span>);<br>  c.pipe(c);<br>&#125;);<br>server.on(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">throw</span> err;<br>&#125;);<br>server.listen(<span class="hljs-number">8124</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;server bound&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>创建新的TCP或IPC服务器</p><p><strong>EventEmitter类</strong><br>Event模块提供了EventEmitter类，用于处理事件，使用以下代码进行初始化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> EventEmitter = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>)<br><span class="hljs-keyword">const</span> eventEmitter = <span class="hljs-keyword">new</span> EventEmitter()<br></code></pre></td></tr></table></figure><p>该对象公开了<code>on</code>和<code>emit</code>方法<br><code>emit</code>用于触发事件<br><code>on</code>用于添加回调函数（会在函数被触发时执行）<br><a href="http://nodejs.cn/learn/the-nodejs-event-emitter">参考文档:Node.js 事件触发器</a></p><p><strong>net.Server类</strong><br>此类用于创建TCP服务器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> net.Server([options][, connectionListener]) <br><span class="hljs-comment">//返回net.Server,即一个TCP服务器</span><br></code></pre></td></tr></table></figure><p>net.connect()与socket.connect及net.socket的区别</p><ol><li>net.connect(),工厂函数，创建新的net.socket，创建好后，立即启动与socket.connect的连接，然后返回启动连接的net.socket，建立连接后，将在返回的套接字上触发connect事件。</li><li>socket.cennect在给定的套接字上发起TCP连接，返回net.socket本身</li><li>socket.connect()函数是异步的，<strong>建立连接后</strong>，触发’connect’事件，如果连接出现问题，则触发error事件并将错误传给error监听器。</li><li>net.socket创建新的套接字对象，返回net.socket</li><li>net.connect是net.createConnection()的别名</li></ol><p>总结：<br><strong>套接字对象</strong></p><ol><li>可以由用户创建并直接用于服务器交互，比如通过net.connect() 创建。</li><li>也可以由net.socket</li></ol><p>net.creatserver([options][, connectionListener])</p><ol><li>创建新的TCP服务器，connectionListener:Function 自动设置为 ‘connection’ 事件的监听器。connection事件</li></ol><p>引用：</p><blockquote><p>我们说过每个进程好比是一座房子，进程的套接字好比是一扇门。应用程序位于房子中门的一侧，运输层位于该门朝外的另一侧，应用程序的开发者再套接字的应用层一侧可以控制所有东西，然而他几乎无法控制运输层一侧。</p></blockquote><blockquote><p>d</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/2022/03/21/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2022/03/21/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>运算符，表达式，语句</title>
    <link href="/2022/03/18/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B007/"/>
    <url>/2022/03/18/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B007/</url>
    
    <content type="html"><![CDATA[<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>JS拥有二元运算符和一元运算符，和一个特殊的三元运算符（条件运算符）,举例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">\\一元运算符<br><span class="hljs-keyword">delete</span>, <span class="hljs-keyword">void</span>, <span class="hljs-keyword">typeof</span>, +, -, ~, !<br><br>\\比较运算符<br>&lt;, &gt;, &lt;=, &gt;=, <span class="hljs-keyword">in</span>, <span class="hljs-keyword">instanceof</span>, <span class="hljs-string">`==`</span>, <span class="hljs-string">`===`</span>, <span class="hljs-string">`!==`</span>, <span class="hljs-string">`!===`</span><br><br>\\条件运算符<br>condition ? ifTrue : ifFalse<br></code></pre></td></tr></table></figure><h3 id="表达式和语句"><a href="#表达式和语句" class="headerlink" title="表达式和语句"></a>表达式和语句</h3><p>JavaScript 中表达式和语句的主要区别在于一条语句执行一个动作，一个表达式产生一个值。意思是一个表达式执行后一定会生成一个值，而语句不一定会产生值。语句主要是用来执行动作，程序就是由一系列语句组成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 表达式</span><br>name<br><span class="hljs-number">1</span> + x<br>getNames()<br><br><span class="hljs-comment">// 语句</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;yang&#x27;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNames</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-keyword">var</span> foo = <span class="hljs-function"><span class="hljs-title">getNames</span>(<span class="hljs-params"></span>)</span> &#123;&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://segmentfault.com/a/1190000021293978">参考文档</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JS变量</title>
    <link href="/2022/03/17/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B006/"/>
    <url>/2022/03/17/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B006/</url>
    
    <content type="html"><![CDATA[<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><strong>var定义变量与let及const定义变量的区别</strong></p><ol><li>变量提升的区别，使用var时，在代码执行时会先声明变量，而JS会把声明的变量赋初值undefined。另外两个有”类提升的行为”，但是并不会默认赋值undefined。因此，var定义的变量可以先使用后定义。</li><li>作用域的区别，ES6出现之前，只有全局变量和函数内的局部变量。ES6出现之后，多出了块级作用域的概念。let及const声明的变量仅在块级作用域中有效。</li><li>var变量可以重新声明和修改，let变量可以被修改但不能重新声明，const变量不能被修改且不能被重新声明。</li></ol><p>注意：使用const声明的变量如果是对象或者数组，对象与数组内部的元素仍然是可变的，但是不可以直接给变量重新赋值，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> meng = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>meng = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]   <span class="hljs-comment">//错误</span><br>meng[<span class="hljs-number">1</span>] = <span class="hljs-number">7</span>  <span class="hljs-comment">//此时，meng = [1,7,3]</span><br></code></pre></td></tr></table></figure><p><strong>原始值与引用值</strong><br>在把一个值赋值给变量时，JS引擎必须确定这个值是原始值还是引用值，保存原始值的变量是按值访问的，操作的就是存储在变量中的实际值；引用值是保存在内存的对象，JS不允许直接访问内存位置，操作对象时，实际上操作的是该对象的引用，而非对象本身。</p><p><strong>变量作用域</strong></p><ol><li>全局变量与局部变量</li><li>全局作用域与局部作用域</li><li>执行上下文之全局上下文与局部上下文，每个函数调用也都有自己的上下文。他们之间彼此的关系是：内部上下文可以通过作用域链访问外部上下文的一切，但是外部上下文无法访问内部上下文的一切。</li></ol><p><strong>作用域链</strong><br>先理解几个概念：</p><p>函数里面的作用域为私有作用域，Windows坐在的作用域为全局作用域。<br>在私有作用域中声明的变量和函数的形参都是私有变量<br>在私有作用域中，代码执行的时候如果遇到一个变量，首先确定它是否为私有变量，如果不是，则往当前作用域的上级作用域查找，知道查到全局作用域为止，这也就是作用域链。</p><p>当函数执行的时候，首先会形成一个新的私有作用域，然后按照如下的步骤执行：</p><ol><li>如果有形参，先给形参赋值</li><li>进行私有作用域中的预解析</li><li>私有作用域中的代码从上到下执行</li></ol><p>函数形成一个新的作用域后，保证了里面的私有变量不受外界干扰（外面修改不了私有的，私有的也修改不了外面的），这也是闭包的概念</p><p><strong>参考文档</strong></p><ul><li><a href="https://www.jianshu.com/p/c3276ff58c93">JavaScript中的预解析</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JS操作符注意点</title>
    <link href="/2022/03/15/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B005/"/>
    <url>/2022/03/15/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B005/</url>
    
    <content type="html"><![CDATA[<p><strong>赋值运算符</strong><br>在赋值时等号右侧的所有操作都会在赋值之前完成。因此，我们可以获取函数的返回值，并将其赋值给一个变量。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a,b</span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br>ourSum = sum(<span class="hljs-number">5</span>, <span class="hljs-number">12</span>);<br></code></pre></td></tr></table></figure><h3 id="会进行类型强制转换的运算符"><a href="#会进行类型强制转换的运算符" class="headerlink" title="会进行类型强制转换的运算符"></a>会进行类型强制转换的运算符</h3><p><strong>相等运算符</strong><br>注意：相等运算符会作“类型强制转换”，如果要比较的值不是同一类型，相等运算符会先执行数据类型转换，然后比较值。而严格相等运算符只比较值，不会进行数据类型转换。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&quot;3&quot;</span> == <span class="hljs-number">3</span>; <span class="hljs-comment">//true</span><br><span class="hljs-string">&quot;3&quot;</span> === <span class="hljs-number">3</span>; <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><p><strong>不等运算符</strong><br>与相等运算符类似，不等运算符在比较的时候也会转换值的数据类型</p><p><strong>大于运算符</strong><br>与相等运算符一样，大于运算符在比较的时候，会转换值的数据类型。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><strong>原始值与引用值</strong><br>在把一个值赋值给变量时，JS引擎必须确定这个值是原始值还是引用值，保存原始值的变量是按值访问的，操作的就是存储在变量中的实际值；引用值是保存在内存的对象，JS不允许直接访问内存位置，操作对象时，实际上操作的是该对象的引用，而非对象本身。</p><p><strong>变量作用域</strong></p><ol><li>全局变量与局部变量</li><li>全局作用域与局部作用域</li><li>执行上下文之全局上下文与局部上下文，每个函数调用也都有自己的上下文。他们之间彼此的关系是：内部上下文可以通过作用域链访问外部上下文的一切，但是外部上下文无法访问内部上下文的一切。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>转义符号与转义字符</title>
    <link href="/2022/03/15/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B004/"/>
    <url>/2022/03/15/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B004/</url>
    
    <content type="html"><![CDATA[<h3 id="转义符号"><a href="#转义符号" class="headerlink" title="转义符号"></a>转义符号</h3><p>定义一个字符串必须要用单引号或双引号来包裹它。那么当你的字符串里面包含引号 “ 或者 ‘ 时该怎么办呢?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> myStr = <span class="hljs-string">&quot;I am a \&quot;double quoted\&quot; string inside \&quot;double quotes\&quot;.&quot;</span>; <br><span class="hljs-built_in">console</span>.log(myStr);<span class="hljs-comment">//myStr = &quot;I am a &quot;double quoted&quot; string inside &quot;double quotes&quot;.&quot;</span><br></code></pre></td></tr></table></figure><p>有了<code>\</code>转义符号，JavaScript 就知道这个单引号或双引号并不是字符串的结尾，而是字符串内的字符。</p><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>引号不是字符串中唯一可以被转义（escaped）的字符。使用转义字符有两个原因：</p><ol><li>首先是可以让你使用无法输入的字符，例如退格。</li><li>其次是可以让你在一个字符串中表示多个引号，而不会出错。</li></ol><p>其他的转义字符如下：<br>|代码|输出|<br>|:—:|:–|<br>|<code>\&#39;</code>|单引号|<br>|<code>\&quot;</code>|双引号|<br>|<code>\\</code>|反斜杠|<br>|<code>\n</code>|换行符|<br>|<code>\r</code>|回车符|<br>|<code>\t</code>|制表符|<br>|<code>\b</code>|退格|<br>|<code>\f</code>|换页符|</p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>jQuery对象和方法</title>
    <link href="/2022/03/14/jquery%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/"/>
    <url>/2022/03/14/jquery%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/</url>
    
    <content type="html"><![CDATA[<h3 id="jQuery对象"><a href="#jQuery对象" class="headerlink" title="jQuery对象"></a>jQuery对象</h3><p>jQuery对象本质是一个伪数组</p><ol><li>定义jQuery对象：<code>$对象名</code></li></ol><h3 id="jQuery核心函数"><a href="#jQuery核心函数" class="headerlink" title="jQuery核心函数"></a>jQuery核心函数</h3><p><code>$();</code>或<code>jQuery();</code>代表调用jquery的核心函数；<br><strong>参数</strong></p><ol><li>接收一个字符串选择器，返回一个jQuery对象，对象中保存了找到的DOM元素 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">var</span> $box1 = $(<span class="hljs-string">&quot;.box1&quot;</span>);<br><span class="hljs-keyword">var</span> $box2 = $(<span class="hljs-string">&quot;#box2&quot;</span>);<br></code></pre></td></tr></table></figure></li><li>接收一个字符串代码片段 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">var</span> $p = $(<span class="hljs-string">&quot;&lt;p&gt;我是段落&lt;/p&gt;&quot;</span>);<br><span class="hljs-built_in">console</span>.log($p);<br>$box1.append($p);<br></code></pre></td></tr></table></figure></li><li>接收一个函数（入口函数） <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JS">$(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    alert(<span class="hljs-string">&quot;hello lnj&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="jQuery方法"><a href="#jQuery方法" class="headerlink" title="jQuery方法"></a>jQuery方法</h3></li><li>例1： <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JS">$.each(obj, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">index, value</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(index, value);<br>&#125;);<br></code></pre></td></tr></table></figure></li><li>例2： <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JS">$.isWindow();<br>$.isArray();<br></code></pre></td></tr></table></figure></li><li>例3： <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JS">$(<span class="hljs-string">&quot;p&quot;</span>).find(<span class="hljs-string">&quot;span&quot;</span>)<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Electron上手</title>
    <link href="/2022/03/13/Electron%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/"/>
    <url>/2022/03/13/Electron%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/</url>
    
    <content type="html"><![CDATA[<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>因为Electron将Node.js嵌入到其二进制文件中，你应用运行时的Node.js版本与你系统中运行的Node.js版本无关。</p><h3 id="主进程"><a href="#主进程" class="headerlink" title="主进程"></a>主进程</h3><p>在 Electron 里，运行 package.json 里 main 脚本的进程被称为主进程。在主进程运行的脚本可以以创建 web 页面的形式展示 GUI。</p><h3 id="主进程和渲染进程的区别"><a href="#主进程和渲染进程的区别" class="headerlink" title="主进程和渲染进程的区别"></a>主进程和渲染进程的区别</h3><p>主进程管理所有页面和与之对应的渲染进程。每个渲染进程都是相互独立的，并且只关心他们自己的网页。</p><p>###Electron应用目录</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">your-app/<br>├── package<span class="hljs-selector-class">.json</span><br>├── <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.js</span><br>└── index.html<br></code></pre></td></tr></table></figure><h3 id="运行创建的应用"><a href="#运行创建的应用" class="headerlink" title="运行创建的应用"></a>运行创建的应用</h3><p>如果已经使用<code>npm</code>全局安装了Electron，只需要按照以下方式运行你的应用</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">electron .<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JS增删改查</title>
    <link href="/2022/03/12/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003/"/>
    <url>/2022/03/12/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003/</url>
    
    <content type="html"><![CDATA[<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h3 id="删除对象中的属性"><a href="#删除对象中的属性" class="headerlink" title="删除对象中的属性"></a>删除对象中的属性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> myDog&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Happy Coder&#x27;</span>;<br>    tails: <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-keyword">delete</span> myDog.tails   <span class="hljs-comment">//删除用delete</span><br></code></pre></td></tr></table></figure><h3 id="更改对象中的属性或方法"><a href="#更改对象中的属性或方法" class="headerlink" title="更改对象中的属性或方法"></a>更改对象中的属性或方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> ourDog = &#123;<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Camper&quot;</span>,<br>  <span class="hljs-string">&quot;legs&quot;</span>: <span class="hljs-number">4</span>,<br>  <span class="hljs-string">&quot;tails&quot;</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-string">&quot;friends&quot;</span>: [<span class="hljs-string">&quot;everything!&quot;</span>]<br>&#125;;<br>ourDog.name = <span class="hljs-string">&quot;Happy Camper&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="访问对象的属性或方法"><a href="#访问对象的属性或方法" class="headerlink" title="访问对象的属性或方法"></a>访问对象的属性或方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> myDog = &#123;<br>    <span class="hljs-attr">tails</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-string">&#x27;More Color&#x27;</span>: <span class="hljs-string">&#x27;red&#x27;</span><br>    shape： <span class="hljs-string">&#x27;square&#x27;</span><br>&#125;<br><span class="hljs-built_in">console</span>.log(myDog.tail);   <span class="hljs-comment">//使用点号访问对象</span><br><span class="hljs-built_in">console</span>.log(myDog[<span class="hljs-string">&#x27;More Color&#x27;</span>]);    <span class="hljs-comment">//当属性名包含空格时，必须使用方括号来获取他的属性值。</span><br></code></pre></td></tr></table></figure><p><strong>JS对象属性通过‘.’和‘[]’访问的区别</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br>obj.name = <span class="hljs-string">&#x27;张三&#x27;</span>;<br><span class="hljs-keyword">var</span> myName = <span class="hljs-string">&#x27;name&#x27;</span>;<br><br><span class="hljs-built_in">console</span>.log(obj.myName);<span class="hljs-comment">//undefined,访问不到对应的属性</span><br><span class="hljs-built_in">console</span>.log(obj[myName]);<span class="hljs-comment">//张三</span><br></code></pre></td></tr></table></figure><ol><li>.操作符：静态的，右侧必须是对象的属性名称。</li><li>[]操作符：动态的，方括号里可以是变量也可以是字符串。</li><li>[]可以通过变量访问，也可以通过字符串访问，但是使用字符串访问时需要加双引号。</li><li>[]可以动态设置属性，哪怕对象中本身没有这个属性，但点操作符不可以。</li></ol><p>参考：<a href="https://segmentfault.com/a/1190000021794888">js对象属性通过“.”和“[ ]”访问的区别</a></p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p><strong>赋值</strong><br>在JavaScript中，字符串的值是不可改变的，意味着字符串一旦被创建就不能被改变。注意，这并不意味着 myStr 永远不能被改变，只是字符串字面量 string literal 的各个字符不能被改变。 改变 myStr 的唯一方法是重新给它赋一个值，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">let</span> myStr = <span class="hljs-string">&quot;Bob&quot;</span>;<br>myStr = <span class="hljs-string">&quot;Job&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="访问字符串内字符"><a href="#访问字符串内字符" class="headerlink" title="访问字符串内字符:"></a>访问字符串内字符:</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">let</span> myStr = <span class="hljs-string">&quot;Bob&quot;</span>;<br><span class="hljs-built_in">console</span>.log(myStr[<span class="hljs-number">0</span>]);<br></code></pre></td></tr></table></figure><p><strong>拼接字符串</strong><br>注意：拼接操作不会在两个字符串之间添加空格，所以，如果想加上空格，需要在字符串里面添加。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="往数组中添加元素"><a href="#往数组中添加元素" class="headerlink" title="往数组中添加元素"></a>往数组中添加元素</h3><p><strong>往数组一端添加元素</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">.push() <span class="hljs-comment">//接受一个或多个参数（parameters），并把它压入到数组的末尾。</span><br>.unshift()   <span class="hljs-comment">//移入元素到数组头部</span><br></code></pre></td></tr></table></figure><h3 id="删除数组内的元素"><a href="#删除数组内的元素" class="headerlink" title="删除数组内的元素"></a>删除数组内的元素</h3><p><strong>将数组一端元素去除</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">.pop()  <span class="hljs-comment">//移除数组中最后一个元素，无参数</span><br>.shift()  <span class="hljs-comment">//移除第一个元素，无参数</span><br></code></pre></td></tr></table></figure><h3 id="访问数组中的元素"><a href="#访问数组中的元素" class="headerlink" title="访问数组中的元素"></a>访问数组中的元素</h3><p><strong>访问数组元素(使用索引访问多维数组)</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> shop = [<span class="hljs-string">&#x27;b&#x27;</span>,[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">5</span>],[<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-number">7</span>]]<br><span class="hljs-built_in">console</span>.log(shop[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数字签名与数字证书</title>
    <link href="/2022/03/11/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AC%94%E8%AE%B002/"/>
    <url>/2022/03/11/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AC%94%E8%AE%B002/</url>
    
    <content type="html"><![CDATA[<h1 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h1><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在信息传输过程中，如果防止信息泄露，信息被篡改以及信息被他人解惑呢？</p><p>为了防止信息伪造和篡改， 有两种解决方案：</p><ol><li>报文摘要，防止信息伪造和篡改，可以证实报文来到可信的源点，没有被篡改。</li><li>数据的完全加密：可以提供防止信息伪造和篡改，但是使用不便。</li></ol><p>如何通信时的确实是对方呢？<br>在互联网通信时，浏览器会验证数字证书是否被篡改，没有的话，</p><p>在实际应用中，报文摘要技术应用广泛，如区块链，客户端-服务器通信，银行卡信息验证都用到了签名技术。</p><h3 id="算法应用"><a href="#算法应用" class="headerlink" title="算法应用"></a>算法应用</h3><p><strong>常见的签名哈希算法如下：</strong></p><p><strong>MD5算法</strong><br>输入：任意长度的消息<br>输出：128比特位消息摘要（用16进制表示需要32位）<br>处理：以512位输入数据块为单位</p><p><strong>SHA-1</strong><br>结构与MD5相似，抗攻击能力比MD5强<br>输入：消息输入长度不超过2^64bit<br>输出：输出160bit<br>处理：按512bit进行处理</p><p><strong>加密数据使用算法与签名算法</strong><br>RSA算法优点是难以破解，缺点是加解密速度慢，因此在实际应用中，RSA用于加解密密钥，DES算法主要用于加解密数据</p><h3 id="数字签名-1"><a href="#数字签名-1" class="headerlink" title="数字签名"></a>数字签名</h3><p>摘要经过加密就得到数字签名，现在假设发送端为Alice，接收端为Bob，流程如下：<br>Alice：</p><ol><li>发送的明文用Bob的公钥加密形成密文</li><li>同时对明文进行摘要计算得到相应的摘要值，用自己的私钥对摘要值进行加密，形成数字签名。</li></ol><p>Bob：</p><ol><li>使用自己的私钥对密文进行解密得到明文，对明文进行相同的摘要计算达到摘要值</li><li>使用Alice的公钥对签名进行解密得到<strong>正确的摘要值</strong>。</li><li>对两个摘要值进行比较，如果一致，证明消息没有被篡改。</li></ol><p><strong>总结</strong><br>Alice用Bob的公钥加密密文，用自己的私钥对摘要值进行加密<br>Bob用自己的私钥对密文解密，用Alice的公钥对签名解密，再对解密的密文进行摘要计算进行对比。</p><p><strong>疑问</strong></p><ol><li>摘要生成过程是用Alice的私钥加密，如果Alice的公钥的被第三者截获，不就可以获取到摘要了么？会不会对安全造成威胁？答案是不会，因为通过摘要不可以逆推原文。</li><li>为什么要对摘要加密后再发送？为什么不直接发摘要？黑客往往不关系你发送了什么，这种方式可以用伪造内容及伪造内容生成的摘要直接替换原始内容及摘要。</li><li>网络上通信的双方可能都不认识对方，怎么认为A,B确实是对方呢？</li><li>Bob在存Alice公钥可能刚开始就被人动了手脚，该怎么预防这个问题呢？通过CA证书</li></ol><h1 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h1><h3 id="证书内容"><a href="#证书内容" class="headerlink" title="证书内容"></a>证书内容</h3><p>数字证书的作用就是来认证公钥持有者的身份，以防第三方进行冒充，一个数字证书通常包含了：</p><ol><li>公钥(通常浏览器和操作系统集成了CA的公钥信息)</li><li>持有者信息</li><li>证书认证机构CA的信息</li><li>签名算法：对摘要进行加密使用的算法。通过签名算法可以拿到服务端给出证书的指纹值</li><li>签名哈希算法（指纹算法）：通过指纹算法计算此刻证书的Hash值。</li><li>指纹: 摘要经过加密得到的就是指纹</li></ol><p>最简单的证书包含了一个公开密钥，名称，及证书授权中心的数字签名。</p><h3 id="CA签发证书过程"><a href="#CA签发证书过程" class="headerlink" title="CA签发证书过程"></a>CA签发证书过程</h3><p>数字证书的创建流程：<a href="https://help.aliyun.com/document_detail/211100.html">https://help.aliyun.com/document_detail/211100.html</a></p><h3 id="如何判断证书是否被篡改"><a href="#如何判断证书是否被篡改" class="headerlink" title="如何判断证书是否被篡改"></a>如何判断证书是否被篡改</h3><ol><li>客户端用CA公钥（通常在浏览器或系统集成）解密签名部分，得到证书签发时对内容进行摘要计算的<strong>正确摘要值1</strong></li><li>客户端对证书的内容使用同样的摘要算法得到摘要值2</li><li>HASH值1与HASH值2对比，如果相同，则为可信赖的证书。</li></ol><p><strong>疑问</strong></p><ol><li>在通信是服务端是如何得到客户端公钥的？</li><li>客户端拥有什么？拥有证书，CA公钥，通过CA公钥解密证书可以得到证书内的信息，比如服务端公钥</li><li></li></ol><h3 id="数字证书的应用——服务器"><a href="#数字证书的应用——服务器" class="headerlink" title="数字证书的应用——服务器"></a>数字证书的应用——服务器</h3><p>可以通过阿里云SSL证书服务购买SSL证书，并向CA中心提交证书申请，直到证书成功签发；您将已签发的证书安装到Web服务器后，则Web服务将会通过HTTPS加密协议来传输数据。<br>HTTPS加密传输协议可激活客户端浏览器到网站服务器之间的SSL加密通道（SSL协议），从而实现高强度双向加密传输，防止传输数据被泄露或篡改。<br><strong>SSL数字证书为什么安全？</strong><br><img src="https://typora-1308512027.cos.ap-beijing.myqcloud.com/Blog/fluid%E4%B8%BB%E9%A2%98/%E5%86%85%E5%AE%B9%E5%9B%BE/2.png" alt="avatar"></p><p><strong>SSL/TLS握手详细过程</strong></p><ol><li>“client hello”消息</li><li>“server hello”消息</li><li>对证书进行验证</li><li>客户端自己生成预主密钥（48位的随机数），通过公钥加密</li><li>服务端用自己的私钥解密得到预主密钥</li><li>客户端和服务端使用相同的算法根据客户端随机数，服务器随机数，预主密钥生产主密钥，之后的通信都使用主密钥进行加密与解密。</li></ol><p><img src="https://typora-1308512027.cos.ap-beijing.myqcloud.com/Blog/fluid%E4%B8%BB%E9%A2%98/%E5%86%85%E5%AE%B9%E5%9B%BE/3.png" alt="avatar"></p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ol><li><a href="https://segmentfault.com/a/1190000021559557">SSL/TLS工作原理和详细握手过程</a></li><li><a href="https://razeencheng.com/posts/ssl-handshake-detail/">HTTPS篇之SSL握手过程详解</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>密码学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>密码学发展阶段</title>
    <link href="/2022/03/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AC%94%E8%AE%B001/"/>
    <url>/2022/03/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AC%94%E8%AE%B001/</url>
    
    <content type="html"><![CDATA[<h1 id="密码学发展阶段"><a href="#密码学发展阶段" class="headerlink" title="密码学发展阶段"></a>密码学发展阶段</h1><h3 id="（一）古典密码阶段（手工、机械阶段-1949）"><a href="#（一）古典密码阶段（手工、机械阶段-1949）" class="headerlink" title="（一）古典密码阶段（手工、机械阶段-1949）"></a>（一）古典密码阶段（手工、机械阶段-1949）</h3><p>古典密码学主要解决的问题就是：我们想要发送的信息，不想要第三方知道，对这个信息进行加密。以下就介绍一些传统加密方法。</p><p>1.凯撒密码<br>主要思想就是按字母表往后平移n个字母，这个n值一般取3。破解的话，全部可能性试一遍就可以，往后平移最多也就 26 种可能的情况。<br><img src="https://typora-1308512027.cos.ap-beijing.myqcloud.com/Blog/fluid%E4%B8%BB%E9%A2%98/%E5%86%85%E5%AE%B9%E5%9B%BE/1.png" alt="avatar"><br>2. 多字母代替，如下<br>ABA→ RTQ􀀹ABB → SLL</p><p>这一时期的问题是：没有隐藏统计信息和关联信息，可用频率分析来破解。</p><h3 id="（二）近代密码学（1949-1975）"><a href="#（二）近代密码学（1949-1975）" class="headerlink" title="（二）近代密码学（1949-1975）"></a>（二）近代密码学（1949-1975）</h3><p>1949年，Shannon发表了一篇 “保密系统的信息理论”的学术文章，标志着密码学阶段的开始。产生了信息论及对称密码（分组密码）。经典算法如下：</p><p><strong>DES算法</strong><br>DES（Data Encryption Standard，数据加密标准）算法是在美国NSA资助下由IBM公司开发的一种对称密码算法，其初衷是为政府非机密的敏感信息提供较强的加密保护。它是美国政府担保的第一种加密算法，并在1977年被正式作为美国联邦信息处理标准。</p><p>DES是一个分组对称加密算法，典型的DES以64位为分组对数据加密，加密和解密用的是同一个算法，密钥长度64位（实际有效位56位，因为每个字节的第8 位都被用作奇偶校验以保证密钥本身正确，不会在密钥分发过程中出错）。DES算法保密性依赖于密钥。</p><p><strong>IDEA算法</strong><br>IDEA（国际数据加密算法）是分组密码算法，分组长度为64位，但密钥长度128位。同一算法既可加密也可解密。<br>IDEA的密钥比DES的多一倍，增加了破译难度，被认为是多年后都有效的算法。</p><p><strong>AES算法</strong><br>1997年1月，美国国家标准技术研究所NIST向全世界密码学界发出征集21世纪AES算法的公告，并成立了AES标准工作研究室，1997年4月15日的例会制定了对AES的评估标准。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一。</p><p>对DES强力解密用1秒，对AES则需要用 149 万亿年</p><h3 id="（三）现代密码学（1976年以后）"><a href="#（三）现代密码学（1976年以后）" class="headerlink" title="（三）现代密码学（1976年以后）"></a>（三）现代密码学（1976年以后）</h3><p>对称密钥密码学指的是发送方与接收方都拥有相同的密钥。直到1976年这都还是唯一的公开加密法。在1976年Diffie和Hellman发表《密码学新方向》提出非对称密码学，并指出加密与解密由不同的密钥完成，这是划时代的事件。经典算法如下：</p><p><strong>RSA算法</strong><br>1978年，由美国麻省理工学院(MIT)的Rivest、Shamir和Adleman在题为《获得数字签名和公开钥密码系统的方法》的论文中提出的，最著名、应用最广泛的公钥系统 。</p><h3 id="（四）基于物理学的密码学"><a href="#（四）基于物理学的密码学" class="headerlink" title="（四）基于物理学的密码学"></a>（四）基于物理学的密码学</h3><p>量子密码，号称最安全的密码，理论基础是量子力学，而以往密码学的理论基础是数学。</p>]]></content>
    
    
    <categories>
      
      <category>密码学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Git学习笔记01</title>
    <link href="/2022/03/09/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/"/>
    <url>/2022/03/09/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Github"><a href="#一、Github" class="headerlink" title="一、Github"></a>一、Github</h1><h3 id="1-如何从GitHub中下载项目？"><a href="#1-如何从GitHub中下载项目？" class="headerlink" title="1. 如何从GitHub中下载项目？"></a>1. 如何从GitHub中下载项目？</h3><p>找到对应的仓库，复制HTTPS或SSH连接，在本地使用<code>git clone</code>命令，项目将会下载下来并保存在你当前命令行所在目录下。</p><p>软件安装位置思考：</p><ol><li>如何安装Scoop以及使用Scoop将软件安装在哪里？</li><li>使用npm将软件安装在哪里？</li><li>使用git clone又将项目安装在哪里？</li></ol><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><h1 id="二、GIT"><a href="#二、GIT" class="headerlink" title="二、GIT"></a>二、GIT</h1><h1 id="三、问题汇总"><a href="#三、问题汇总" class="headerlink" title="三、问题汇总"></a>三、问题汇总</h1><h3 id="1-git-status不能显示中文"><a href="#1-git-status不能显示中文" class="headerlink" title="1. git status不能显示中文"></a>1. git status不能显示中文</h3><p><strong>现象</strong><br>  status查看有改动但未提交的文件时总只显示数字串，显示不出中文文件名，非常不方便。</p><p><strong>原因分析</strong><br>  在默认设置下，中文文件名在工作区状态输出，中文名不能正确显示，而是显示为八进制的字符编码。</p><p><strong>解决方案</strong><br>  git bash 终端输入命令：<code>git config --global core.quotepath false</code><br>  注释：将git 配置文件 <code>core.quotepath</code>项设置为false。quotepath表示引用路径，加上–global表示全局配置</p><h3 id="2-在更换butterfly主题后，git-add后报错，"><a href="#2-在更换butterfly主题后，git-add后报错，" class="headerlink" title="2. 在更换butterfly主题后，git add后报错，"></a>2. 在更换butterfly主题后，git add后报错，</h3><p><strong>现象如下</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">You&#x27;ve added another git repository inside your current repository.<br>hint: Clones of the outer repository will not contain the contents of<br>hint: the embedded repository and will not know how to obtain it.<br>hint: If you meant to add a submodule, use:<br>hint: git submodule add &lt;url&gt; themes/butterfly<br>hint: If you added this path by mistake, you can remove it from the<br>hint: index with:<br>hint: git rm --cached themes/butterfly<br>hint: See &quot;git help submodule&quot; for more information.<br></code></pre></td></tr></table></figure><p><strong>解决方案</strong><br>使用<code>git rm --cached themes/butterfly</code>后重新git add</p><h3 id="3-关于-LF-will-be-replaced-by-CRLF-问题出现的原因"><a href="#3-关于-LF-will-be-replaced-by-CRLF-问题出现的原因" class="headerlink" title="3. 关于 LF will be replaced by CRLF 问题出现的原因"></a>3. 关于 LF will be replaced by CRLF 问题出现的原因</h3><p><strong>现象</strong><br>在使用<code>git add</code>时，会出现一个警告:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">warning: LF will be replaced by CRLF <span class="hljs-keyword">in</span> <span class="hljs-built_in">source</span>/_posts/vim-learn.md.<br>The file will have its original line endings <span class="hljs-keyword">in</span> your working directory<br></code></pre></td></tr></table></figure><p><strong>原因</strong><br>LF是Linux下的换行符，CRLF是Windows下的换行符，在执行add时出现这个表示工作区的文件都应该用CRLF来换行。<br>Git工作区默认为CRLF为换行符，当我们改动时，当推送到远程仓库的时候git会统一格式全部转化为用CRLF作为换行符。</p><h3 id="4-回车和换行的区别"><a href="#4-回车和换行的区别" class="headerlink" title="4. 回车和换行的区别"></a>4. 回车和换行的区别</h3><p><strong>现象</strong><br>Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。</p><p><strong>原因</strong><br>Unix系统里，每行结尾只有”&lt;换行&gt;”，即”\n”；Windows系统里面，每行结尾是”&lt;回车&gt;&lt;换行&gt;”，即”\r\n”；Mac系统里，每行结尾是”&lt;回车&gt;”。</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JS预解析</title>
    <link href="/2022/03/09/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/"/>
    <url>/2022/03/09/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/</url>
    
    <content type="html"><![CDATA[<h3 id="1-1-什么是预解析"><a href="#1-1-什么是预解析" class="headerlink" title="1.1 什么是预解析"></a>1.1 什么是预解析</h3><p>预解析：JavaScript执行任何代码之前，JavaScript解析器会在全局环境下查找var、function等关键词，进行提前的声明。</p><h3 id="1-2-var声明的变量和function声明的函数在预解析时的区别"><a href="#1-2-var声明的变量和function声明的函数在预解析时的区别" class="headerlink" title="1.2 var声明的变量和function声明的函数在预解析时的区别"></a>1.2 var声明的变量和function声明的函数在预解析时的区别</h3><p>var声明的变量在预解析的时候只是进行提前的声明，function声明的函数在预解析的时候会提前声明并且会同时定义但不会调用。也就是说变量提升只提升声明不提升赋值，函数提升会声明且赋值，但不会调用。</p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS引号问题思考</title>
    <link href="/2022/03/08/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/"/>
    <url>/2022/03/08/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/</url>
    
    <content type="html"><![CDATA[<h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><p><strong>JS标识符的命名规则，即变量的命名规则：</strong></p><ol><li>标识符只能由字母、数字、下划线和‘$’组成</li><li>数字不可以作为标识符的首字符</li></ol><p><strong>对象属性的命名规则：</strong></p><ol><li>通过[]操作符为对象添加属性时，属性名称可以是任何字符串（包括只包含空格的字符串和空字符串）；</li><li>通过.操作符为对象添加属性时，属性名称必须是合法的标识符名称；</li><li>如果属性名包含非法的标识符字符，则只能采用obj[“propertyName”]的形式；</li><li>如果属性名是合法的标识符，读取时即可以采用obj.propertyName,也可以采用obj[“propertyName”]的形式<h3 id="JS对象的属性名要不要加引号？"><a href="#JS对象的属性名要不要加引号？" class="headerlink" title="JS对象的属性名要不要加引号？"></a>JS对象的属性名要不要加引号？</h3></li></ol><p><strong>在JS中，如果对象有非字符串属性的话，JS会自动将他们转换为字符串。</strong></p><p>一般情况下，属性名加引号与不加引号都是可以的，但有些不符合规范的属性名必须加引号，如下：</p><ol><li>如果属性名是数字开头，则必须有双引号，并且只能用[]方括号访问Value，如下 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-string">&quot;333age&quot;</span>: <span class="hljs-string">&#x27;这个正确&#x27;</span>,<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span><br>&#125;;<br><span class="hljs-built_in">console</span>.log(obj[<span class="hljs-string">&quot;333&quot;</span>]);<br></code></pre></td></tr></table></figure></li><li>纯数字的属性名（使用[]访问，并且可以去掉’’），如下： <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-string">&#x27;3&#x27;</span>: <span class="hljs-string">&#x27;abc&#x27;</span><br>&#125;<br><span class="hljs-built_in">console</span>.log(obj[<span class="hljs-number">3</span>]);<br></code></pre></td></tr></table></figure></li></ol><h3 id="布尔值用加引号吗？"><a href="#布尔值用加引号吗？" class="headerlink" title="布尔值用加引号吗？"></a>布尔值用加引号吗？</h3><p>布尔值是不带引号的。字符串”true”和”false”不是布尔值，在JavaScript中也没有特殊含义。</p><h3 id="JSON对象值访问"><a href="#JSON对象值访问" class="headerlink" title="JSON对象值访问"></a>JSON对象值访问</h3><p>访问方式和JS对象的访问方式相似：</p><ol><li>可以使用点号’.’来访问对象的值，如下： <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">var</span> myObj, x;<br>myObj = &#123; <span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;runoob&quot;</span>, <span class="hljs-string">&quot;alexa&quot;</span>:<span class="hljs-number">10000</span>, <span class="hljs-string">&quot;site&quot;</span>:<span class="hljs-literal">null</span> &#125;;<br>x = myObj.name;<br></code></pre></td></tr></table></figure></li><li>也可以使用中括号来访问对象的值，如下： <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">var</span> myObj, x;<br>myObj = &#123; <span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;runoob&quot;</span>, <span class="hljs-string">&quot;alexa&quot;</span>:<span class="hljs-number">10000</span>, <span class="hljs-string">&quot;site&quot;</span>:<span class="hljs-literal">null</span> &#125;;<br>x = myObj[<span class="hljs-string">&quot;name&quot;</span>];<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node.js学习笔记02</title>
    <link href="/2022/03/08/Node.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/"/>
    <url>/2022/03/08/Node.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/</url>
    
    <content type="html"><![CDATA[<p>上午，回顾了几个知识点，Node.js方面如下：</p><ol><li>浏览器通过MIME类型来决定如何处理URL，在NodeJS中，通过writeHead方法设置Content-Type告诉浏览器将以什么形式、什么编码读取这个文件。<br>语法格式：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">res.writeHead(<span class="hljs-number">200</span>, &#123;<br>     <span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;text/plain; charset=utf-8&quot;</span><br> &#125;);<br></code></pre></td></tr></table></figure></li><li><code>path.extname(path)</code>是获取路径的扩展名称</li><li><code>path.dirname()</code>用于获取路径中的目录, 也就是除了最后一个部分以外的内容`</li><li><code>response.writeHead(statusCode[, statusMessage][, headers])</code>中的statusMessage可以是json对象键值对形式，如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JS">res.writeHead(<span class="hljs-number">200</span>, &#123;<br><span class="hljs-string">&#x27;Content-Length&#x27;</span>: Buffer.byteLength(body),<br><span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;text/plain&#x27;</span>&#125;)<br></code></pre></td></tr></table></figure></li></ol><p>在使用Ubuntu系统时也遇到了些问题，重新回顾了一些知识点，如下：</p><ol><li>查看端口占用情况<code>lsof -i:端口号</code>，pid为进程标识符。</li><li>在查看到端口占用的进程后，可使用<code>kill -9 PID</code>杀掉对应的进程。</li></ol>]]></content>
    
    
    <categories>
      
      <category>NodeJS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vim学习使用</title>
    <link href="/2021/12/25/vim-learn/"/>
    <url>/2021/12/25/vim-learn/</url>
    
    <content type="html"><![CDATA[<h1 id="一、normal模式"><a href="#一、normal模式" class="headerlink" title="一、normal模式"></a>一、normal模式</h1><h3 id="1-各种插入"><a href="#1-各种插入" class="headerlink" title="1. 各种插入"></a>1. 各种插入</h3><ol><li>输入i–&gt;在光标前插入</li><li>输入a–&gt;在光标后插入</li><li>输入o–&gt;在当前行后插入一个新行</li><li>输入O–&gt;在当前行前插入一个新行</li><li>输入cw–&gt;替换从光标所在位置到一个单词结尾的字符</li></ol><h3 id="2-查找"><a href="#2-查找" class="headerlink" title="2. 查找"></a>2. 查找</h3><ol><li>n–&gt;查找下一个</li><li>N–&gt;回到上一个</li></ol><h3 id="3-简单的移动光标"><a href="#3-简单的移动光标" class="headerlink" title="3. 简单的移动光标"></a>3. 简单的移动光标</h3><ol><li>0–&gt;数字零，到一行开头</li><li>&amp;–&gt;到本行行尾</li><li>上下左右移动</li></ol><h3 id="4-快速移动光标"><a href="#4-快速移动光标" class="headerlink" title="4. 快速移动光标"></a>4. 快速移动光标</h3><ol><li>ctrl+f–&gt;向下翻页</li><li>ctrl+b–&gt;向上翻页</li><li>NG–&gt;到第N行(注意命令中的G是大写的)</li><li>gg–&gt;到第一行</li><li>G–&gt;到最后一行</li><li>.重复上一次命令</li></ol><h3 id="5-拷贝粘贴删除"><a href="#5-拷贝粘贴删除" class="headerlink" title="5. 拷贝粘贴删除"></a>5. 拷贝粘贴删除</h3><ol><li>x–&gt;删除光标所在位置的字符</li><li>yw–&gt;拷贝一个单词</li><li>y2w–&gt;拷贝两个单词</li><li>yy/Y–&gt;拷贝当前行</li><li>输入v,可以选择一段文本。输入y复制，再输入p粘贴。</li><li>输入dd删除当前行，并把删除的行存在剪切板里；输入p粘贴剪切板的内容</li></ol><h3 id="6-保存退出"><a href="#6-保存退出" class="headerlink" title="6. 保存退出"></a>6. 保存退出</h3><ol><li>:x/ZZ/:wq. n+命令–&gt;重复n次，例如2dd–&gt;删除两行</li></ol><h3 id="7-其他"><a href="#7-其他" class="headerlink" title="7.其他"></a>7.其他</h3><ol><li>u–&gt;撤销</li><li>ctrl+r–&gt;重做</li><li>:w–&gt;存盘</li><li>:e–&gt;打开一个文件</li><li>:ls–&gt;打开多个文件时，查看都打开了什么</li><li>:b对应序号，打开对应文件</li><li>:bn和:bp–&gt;我们可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件。</li><li>:qa–&gt;退出所有的缓冲区</li><li>:saveas 文件名–&gt;另存为</li></ol><h3 id="8-快速操作"><a href="#8-快速操作" class="headerlink" title="8. 快速操作"></a>8. 快速操作</h3><ol><li>n<code>COMMAND</code>–&gt;重复某个命令n次</li><li>:+行号–&gt;跳转对应的行</li><li>w–&gt;到下一个单词的开头</li><li>e–&gt;到下一个单词的结尾</li><li>一定要记住光标的移动，因为很多命令都可以和这些移动光标的命令连动，很多命令都可以如下来干:&lt;stat position&gt;&lt;command&gt;&lt;end position&gt;<br>例如：0y$–&gt;先到行头，从这里开始拷贝，拷贝到本行最后一个字符</li><li>gu–&gt;变小写</li><li>gU–&gt;变大写</li></ol><h1 id="二、Insert模式"><a href="#二、Insert模式" class="headerlink" title="二、Insert模式"></a>二、Insert模式</h1>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Next主题配置问题</title>
    <link href="/2021/12/21/next-configure-issue/"/>
    <url>/2021/12/21/next-configure-issue/</url>
    
    <content type="html"><![CDATA[<h3 id="1-next主题侧边栏日志无法正常跳转"><a href="#1-next主题侧边栏日志无法正常跳转" class="headerlink" title="1. next主题侧边栏日志无法正常跳转"></a>1. next主题侧边栏日志无法正常跳转</h3><p>现象：日志出现<code>Cannot GET /archives/%7C%7C%20archives/</code>问题</p><p>网上的解决办法：</p><ol><li><p><code>themes/next/_config.yml</code>文件下将<code>archives：/archives/ || archive</code> 改成<code>archives：/archives/</code>，删掉后面的<code>||archive</code>，的确能够解决问题，但是就没有图标了</p></li><li><p>Next主题目录下<code>/layout/_macro/sidebar.swig</code>文件中找到</p> <figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">url_for</span>(<span class="hljs-name">theme.menu.archives</span>).split(<span class="hljs-name">&#x27;||&#x27;</span>)[0] | trim &#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p> 原因是<code>url_for</code>函数将<code>||</code>转码了，将此改为</p> <figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">url_for</span>(<span class="hljs-name">theme.menu.archives.split</span>(<span class="hljs-name">&#x27;||&#x27;</span>)[0])| trim&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="2-修改文章底部标签的-的样式"><a href="#2-修改文章底部标签的-的样式" class="headerlink" title="2. 修改文章底部标签的#的样式"></a>2. 修改文章底部标签的<code>#</code>的样式</h3></li><li><p>打开模板/themes/next/layout/_macro/post.swig</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;footer <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;post-footer&quot;</span>&gt;<br>    &#123;% <span class="hljs-keyword">if</span> post.tags and post.tags.length and not is_index %&#125;<br>    &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;post-tags&quot;</span>&gt;<br>        &#123;% <span class="hljs-keyword">for</span> tag <span class="hljs-keyword">in</span> post.tags %&#125;<br>        &lt;a href=<span class="hljs-string">&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot;</span> rel=<span class="hljs-string">&quot;tag&quot;</span>&gt;# &#123;&#123; tag.name &#125;&#125;&lt;/a&gt;<br>        &#123;% endfor %&#125;<br>    &lt;/div&gt;<br>    &#123;% endif %&#125;<br></code></pre></td></tr></table></figure></li><li><p>搜索<code>rel=&quot;tag&quot;&gt;#</code>，将#换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code>即可</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Next主题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Next主题配置</title>
    <link href="/2021/12/21/next-configure/"/>
    <url>/2021/12/21/next-configure/</url>
    
    <content type="html"><![CDATA[<h3 id="next主题添加字数统计和阅读时长估计"><a href="#next主题添加字数统计和阅读时长估计" class="headerlink" title="next主题添加字数统计和阅读时长估计"></a>next主题添加字数统计和阅读时长估计</h3><blockquote><p>注：Next主题版本 v5.1.4</p></blockquote><ul><li><strong>1.安装相关的插件</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm i --save hexo-wordcount <br></code></pre></td></tr></table></figure><ul><li><strong>2.更改主题配置文件</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> 博客目录<br>vim themes/next/_config.yml<br><br><span class="hljs-comment"># 这些都是配置文件里都有的，将其值都设置为true，</span><br><span class="hljs-comment"># Post wordcount display settings</span><br><span class="hljs-comment"># Dependencies: https://github.com/willin/hexo-wordcount</span><br>post_wordcount:<br>  item_text: <span class="hljs-literal">true</span>   <span class="hljs-comment">#是否显示文字</span><br>  wordcount: <span class="hljs-literal">true</span>   <span class="hljs-comment">#显示字数</span><br>  min2read: <span class="hljs-literal">true</span>    <span class="hljs-comment">#显示阅读时间</span><br>  totalcount: <span class="hljs-literal">true</span>  <span class="hljs-comment">#显示总数</span><br>  separated_meta: <span class="hljs-literal">true</span> <span class="hljs-comment">#是否分开</span><br></code></pre></td></tr></table></figure><ul><li><strong>3.修改主题相关界面文件</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> 博客目录<br>vim themes/next/layout/_macro/post.swig<br></code></pre></td></tr></table></figure><p>更改两处值，找到该值，在后面添加中文单位即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;&#123;</span></span><br><span class="hljs-string"><span class="hljs-tag">    &#123; __(&#x27;post.wordcount&#x27;) &#125;&#125;&quot;</span>&gt;</span><br>    &#123;<br>    &#123;<br>     wordcount(post.content) &#125;&#125; 字<br><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;&#123;</span></span><br><span class="hljs-string"><span class="hljs-tag">    &#123; __(&#x27;post.min2read&#x27;) &#125;&#125;&quot;</span>&gt;</span><br>    &#123;<br>    &#123;<br>     min2read(post.content) &#125;&#125; 分钟<br><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><strong>4.重新生成博客</strong></li></ul><h3 id="设置代码高亮显示"><a href="#设置代码高亮显示" class="headerlink" title="设置代码高亮显示"></a>设置代码高亮显示</h3><p>设置前准备：</p><ol><li>Hexo 支持用任何格式书写文章，只需安装相应渲染插件即可。Hexo 默认的Markdown渲染器是hexo-renderer-marked，由此驱动</li><li>prismjs介绍：Prism是一种轻量级的，可扩展的语法突出显示工具，在构建时考虑了现代Web标准。</li><li>PrismJS 默认禁用。启用 PrimeJS 前应设置 highlight.enable 为 false。</li><li>prismjs设置为true后，文章排版变乱</li><li>代码高亮是用 hexo 内部的 prism 插件完成的，你可以看看你的代码编程语言是否写对了</li><li>当 highlight.enable 和 prismjs.enable 均为 false 时，代码块输出的 HTML 由相应的渲染器控制。</li></ol>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Next主题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node.js学习笔记01</title>
    <link href="/2021/12/20/Node.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/"/>
    <url>/2021/12/20/Node.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/</url>
    
    <content type="html"><![CDATA[<h3 id="1-Noedjs介绍"><a href="#1-Noedjs介绍" class="headerlink" title="1. Noedjs介绍"></a>1. Noedjs介绍</h3><p>Node.js是一个基于Chrome V8引擎的JavaScript运行环境，一个让 JavaScript 运行在服务端的开发平台。安装与配置如下：</p><p>使用Scoop包管理工具安装Node.js</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scoop install nodejs-lts<br></code></pre></td></tr></table></figure><h3 id="2-node-modules介绍"><a href="#2-node-modules介绍" class="headerlink" title="2. node_modules介绍"></a>2. node_modules介绍</h3><p>node_modules是安装node后用来存放包管理工具下载安装的包的文件夹。npm与node_modules及Node.js的关系如下：</p><ul><li>npm是随同Node.js一起安装的包管理工具</li><li>npm下载安装的包就放在node_modules中</li><li>package.json记录了下载的包的具体描述</li></ul><h3 id="3-使用npm将软件安装到了哪里"><a href="#3-使用npm将软件安装到了哪里" class="headerlink" title="3. 使用npm将软件安装到了哪里"></a>3. 使用npm将软件安装到了哪里</h3><p>默认情况下，当输入<code>npm install hexo</code>命令时，例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install hexo<br></code></pre></td></tr></table></figure><p>软件会被安装到当前文件树中的<code>node_modules</code>模块中。</p><p>使用<code>-g</code>标志可以执行全局安装</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><p>在这种情况下，<code>npm</code>不会将软件包安装在本地文件下，而是使用全局的位置。</p><p>全局的位置在哪里呢？</p><p><code>npm root -g</code>会告知其在计算机上的正确位置</p><h3 id="4-使用npm卸载包"><a href="#4-使用npm卸载包" class="headerlink" title="4. 使用npm卸载包"></a>4. 使用npm卸载包</h3><p>卸载node_modules目录下的包<code>npm uninstall &lt;package&gt;</code><br>卸载全局安装的包<code>npm uninstall -g &lt;package&gt;</code><br>如需从package.json中删除依赖项,需要在命令后添加参数–save</p><h3 id="5-项目上传到GitHub为什么要忽略node-modules文件夹"><a href="#5-项目上传到GitHub为什么要忽略node-modules文件夹" class="headerlink" title="5. 项目上传到GitHub为什么要忽略node_modules文件夹?"></a>5. 项目上传到GitHub为什么要忽略node_modules文件夹?</h3><p>node_modules不是自己的源代码，这些文件信息已经存在package.json中，只要把package.json放上去，运行<code>npm install</code>会自动把node_modules文件夹建立起来，和自己node_modules文件夹的内容一样。</p><h3 id="6-npm常用命令总结"><a href="#6-npm常用命令总结" class="headerlink" title="6. npm常用命令总结"></a>6. npm常用命令总结</h3><ol><li><code>npm init</code> 生成package.json文件</li><li><code>npm install</code> 一次性把<code>package.json</code>文件中<code>dependencies</code>选项中的依赖项全部安装</li><li><code>npm install 包名 --save</code> 下载并保存依赖项</li><li><code>npm uninstall 包名</code> 只删除包，如果有依赖信息不会被删除</li><li><code>npm uninstall 包名 --save</code> 删除的同时把依赖项信息也删除</li></ol>]]></content>
    
    
    <categories>
      
      <category>NodeJS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJS</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
